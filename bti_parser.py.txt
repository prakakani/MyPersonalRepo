#!/usr/bin/env python3
"""
Enhanced D5FD Record Parser Tool
Parses D5FD BTI record data including ND5FDBTI sub-structures based on ND5FDTYP
"""

import re
import codecs

class D5FDEnhancedParser:
    def __init__(self):
        # Main header fields
        self.header_fields = [
            # Standard Header (ND5FDHDR)
            ("ND5FDBID", 0x000, 2, "BIT", "RECORD ID = X'D5FD'"),
            ("ND5FDCHK", 0x002, 1, "BIT", "RECORD CODE CHECK"),
            ("ND5FDCTL", 0x003, 1, "BIT", "CONTROL BYTE"),
            ("ND5FDPGM", 0x004, 4, "CHAR", "LAST PROGRAM TO FILE"),
            ("ND5FDFCH", 0x008, 4, "FA4", "FORWARD CHAIN ADDRESS"),
            ("ND5FDBCH", 0x00C, 4, "FA4", "BACKCHAIN ADDRESS"),
            ("SPARE1", 0x010, 16, "SPARE", "SPARES"),
            # BARTS Control Header (ND5FDCHD)
            ("ND5FDTYP", 0x020, 3, "CHAR", "BARTS RECORD TYPE"),
            ("ND5FDETK", 0x023, 1, "CHAR", "ELECTRONIC DOCUMENT"),
            ("ND5FDBNC", 0x024, 2, "CHAR", "BLOCK NBR IN CHAIN"),
            ("ND5FDNBC", 0x026, 2, "CHAR", "TOTAL NBR OF BLOCKS"),
            ("ND5FDSN1", 0x028, 2, "BIN", "SEQUENCE NBR OF BLOCK"),
            ("ND5FDSN2", 0x02A, 2, "BIN", "TOTAL NBR OF BLOCKS SENT"),
            ("ND5FDNAB", 0x02C, 2, "BIN", "NEXT AVAILABLE BYTE"),
            ("ND5FDCIR", 0x02E, 2, "BIN", "COUNT OF DATA ITEMS"),
            # System Security Controls (ND5FDSSC)
            ("ND5FDRTI", 0x030, 1, "BIT", "RETRANSMIT INDICATOR"),
            ("ND5FDEXT", 0x031, 1, "CHAR", "XT TAXES ELIMINATED"),
            ("ND5FDMUR", 0x032, 1, "CHAR", "BARTS USER INDICATOR"),
            ("SPARE2", 0x033, 1, "SPARE", "SPARE"),
            ("ND5FDH01", 0x034, 4, "BIN", "HASHTOTAL #1"),
            ("ND5FDH02", 0x038, 4, "BIN", "HASHTOTAL #2"),
            ("ND5FDH03", 0x03C, 2, "BIN", "HASHTOTAL #3"),
            ("ND5FDH04", 0x03E, 2, "BIN", "HASHTOTAL #4"),
            ("ND5FDH05", 0x040, 2, "BIN", "HASHTOTAL #5"),
            ("ND5FDH06", 0x042, 2, "BIN", "HASHTOTAL #6"),
            ("ND5FDH07", 0x044, 2, "BIN", "HASHTOTAL #7"),
            ("ND5FDH08", 0x046, 2, "BIN", "HASHTOTAL #8"),
            ("ND5FDH09", 0x048, 4, "BIN", "HASHTOTAL #9"),
            ("ND5FDH10", 0x04C, 2, "BIN", "HASHTOTAL #10"),
            ("ND5FDH11", 0x04E, 2, "BIN", "HASHTOTAL #11"),
            ("ND5FDH12", 0x050, 4, "BIN", "HASHTOTAL #12"),
            ("SPARE3", 0x054, 7, "SPARE", "SPARES"),
            ("ND5FDTER", 0x05B, 3, "BIT", "CONNECTIVITY TRANSMISSION ERRORS"),
            ("ND5FDTCI", 0x05E, 2, "BIN", "TOTAL COUNT OF ITINERARY SEGMENTS"),
        ]
        
        # TAR structure fields (ND5FDTAR) - offset from 0x060
        self.tar_fields = [
            # Ticketing Number Area
            ("ND5FDTKN", 0x000, 14, "CHAR", "TICKET NUMBER"),
            ("ND5FDCTN", 0x00E, 3, "CHAR", "CONJUNCTION TICKET NBR RANGE"),
            ("ND5FDPNL", 0x011, 6, "CHAR", "PNR LOCATOR"),
            ("ND5FDCCP", 0x017, 1, "BIT", "CREDIT CARD RESTRICTIONS"),
            # Fare Data Area
            ("ND5FDBDI", 0x018, 1, "CHAR", "BASE FARE DECIMAL INDICATOR"),
            ("ND5FDBEI", 0x019, 1, "CHAR", "INVOL/REISSUE BACKGROUND"),
            ("ND5FDTBS", 0x01A, 8, "PIC", "BASE FARE AMOUNT"),
            ("ND5FDTCC", 0x022, 3, "CHAR", "BASE FARE CURRENCY CODE"),
            ("ND5FDFCC", 0x025, 3, "CHAR", "TOTAL FARE CURRENCY CODE"),
            ("ND5FDTDI", 0x028, 1, "CHAR", "TOTAL FARE DECIMAL INDICATOR"),
            ("SPARE_TAR1", 0x029, 1, "SPARE", "SPARE BYTE"),
            ("ND5FDTTF", 0x02A, 8, "PIC", "TOTAL FARE"),
            ("ND5FDFTA", 0x032, 8, "PIC", "FARE TAX TOTAL AMOUNT"),
            ("ND5FDPTA", 0x03A, 8, "PIC", "FORM OF PAYMENT TAX TOTAL"),
            ("SPARE_TAR2", 0x042, 24, "SPARE", "SPARE BYTES"),
            ("ND5FDFPI", 0x05A, 1, "BIT", "FARE PRICING INDICATOR"),
            ("ND5FDFTI", 0x05B, 2, "CHAR", "FARE TYPE INDICATOR"),
        ]
        
        # REF structure fields (ND5FDREF) - offset from 0x060
        self.ref_fields = [
            ("ND5FDREC", 0x000, 14, "CHAR", "REFUND RECEIPT NUMBER"),
            ("ND5FDCCA", 0x00E, 21, "CHAR", "TYPE OF PAYMENT"),
            ("ND5FDPCN", 0x023, 29, "CHAR", "PASSENGER NAME"),
            ("ND5FDRCR", 0x040, 3, "CHAR", "CURRENCY CODE"),
            ("ND5FDINV", 0x043, 1, "CHAR", "INVOLUNTARY INDICATOR"),
            ("ND5FDORG", 0x044, 3, "CHAR", "ORIGIN CITY CODE"),
            ("ND5FDDES", 0x047, 3, "CHAR", "DESTINATION CITY CODE"),
            ("ND5FDTRA", 0x04A, 8, "CHAR", "TRAVEL AGY IDENTIFIER-IATA"),
            ("ND5FDAGY", 0x052, 5, "CHAR", "AGENCY COMMISSION"),
            ("ND5FDISS", 0x057, 3, "CHAR", "ISSUING CARRIER"),
            ("ND5FDFAA", 0x05A, 8, "CHAR", "FARE AMOUNT"),
            ("ND5FDTC1", 0x062, 3, "CHAR", "1ST MISC TRANSACTION CODE"),
            ("ND5FDTC2", 0x065, 3, "CHAR", "2ND MISC TRANSACTION CODE"),
            ("ND5FDTC3", 0x068, 3, "CHAR", "3RD MISC TRANSACTION CODE"),
            ("ND5FDTA1", 0x06B, 8, "CHAR", "1ST MISC TRANSACTION AMOUNT"),
            ("ND5FDTA2", 0x073, 8, "CHAR", "2ND MISC TRANSACTION AMOUNT"),
            ("ND5FDTA3", 0x07B, 8, "CHAR", "3RD MISC TRANSACTION AMOUNT"),
        ]

    def hex_to_bytes(self, hex_string):
        """Convert hex string to bytes"""
        hex_clean = hex_string.replace(' ', '').replace('\n', '')
        return bytes.fromhex(hex_clean)

    def ebcdic_to_ascii(self, data):
        """Convert EBCDIC bytes to ASCII string"""
        try:
            return codecs.decode(data, 'cp037').rstrip('\x00').rstrip(' ')
        except:
            return data.hex().upper()

    def format_value(self, field_data, field_type):
        """Format field value based on type"""
        if field_type == "CHAR":
            return self.ebcdic_to_ascii(field_data)
        elif field_type == "BIN":
            return str(int.from_bytes(field_data, 'big'))
        elif field_type == "PIC":
            return self.ebcdic_to_ascii(field_data)
        elif field_type == "BIT":
            return field_data.hex().upper()
        elif field_type == "SPARE":
            return "(SPARE)"
        else:
            return field_data.hex().upper()

    def get_record_type(self, data):
        """Extract ND5FDTYP to determine structure type"""
        if len(data) > 0x022:
            type_data = data[0x020:0x023]
            return self.ebcdic_to_ascii(type_data).strip()
        return "UNK"

    def parse_header(self, data):
        """Parse header fields"""
        print("=" * 80)
        print("HEADER FIELDS")
        print("=" * 80)
        print(f"{'Field Name':<12} {'Offset':<8} {'Length':<8} {'HEX Value':<20} {'Value':<20} {'Description'}")
        print("-" * 80)
        
        for field_name, offset, length, field_type, description in self.header_fields:
            if offset + length <= len(data):
                field_data = data[offset:offset + length]
                hex_value = field_data.hex().upper()
                formatted_value = self.format_value(field_data, field_type)
                print(f"{field_name:<12} {offset:04X}h    {length:<8} {hex_value:<20} {formatted_value:<20} {description}")

    def parse_bti_structure(self, data, record_type):
        """Parse ND5FDBTI structure based on record type"""
        bti_offset = 0x060
        
        print("\n" + "=" * 80)
        print(f"ND5FDBTI STRUCTURE - TYPE: {record_type}")
        print("=" * 80)
        print(f"{'Field Name':<12} {'Offset':<8} {'Length':<8} {'HEX Value':<20} {'Value':<20} {'Description'}")
        print("-" * 80)
        
        # Select appropriate field structure based on record type
        if record_type in ["TAR", "NBT"]:
            fields = self.tar_fields
            print("Using TAR (Ticket Accounting Record) structure")
        elif record_type == "REF":
            fields = self.ref_fields
            print("Using REF (Refund) structure")
        else:
            print(f"Unknown record type: {record_type}, using generic parsing")
            # Show raw hex data for unknown types
            if len(data) > bti_offset:
                raw_data = data[bti_offset:bti_offset + min(100, len(data) - bti_offset)]
                print(f"Raw BTI Data: {raw_data.hex().upper()}")
            return
        
        print("-" * 80)
        
        for field_name, rel_offset, length, field_type, description in fields:
            abs_offset = bti_offset + rel_offset
            if abs_offset + length <= len(data):
                field_data = data[abs_offset:abs_offset + length]
                hex_value = field_data.hex().upper()
                formatted_value = self.format_value(field_data, field_type)
                print(f"{field_name:<12} {abs_offset:04X}h    {length:<8} {hex_value:<20} {formatted_value:<20} {description}")

    def parse_record(self, hex_input):
        """Parse complete D5FD record"""
        try:
            data = self.hex_to_bytes(hex_input)
            
            print("D5FD Enhanced Record Parser Results")
            print(f"Total Data Length: {len(data)} bytes")
            
            # Parse header
            self.parse_header(data)
            
            # Get record type and parse BTI structure
            record_type = self.get_record_type(data)
            self.parse_bti_structure(data, record_type)
            
            print("\n" + "=" * 80)
            
        except Exception as e:
            print(f"Error parsing record: {e}")

def main():
    parser = D5FDEnhancedParser()
    
    sample_input = """D5FD0000 C2C1C3C1 00000000 00000000
E5D6C900 F0F1F0F1 00010000 00000000
F0F0F6F4 F7F6F9F9 F9F8F8F0 F1F14040
5928F4F5 F5F123F3 F5F4F5F5 F1F2F3F5
D3C1E7E6 C5C240D4 00000000 00000000
00000000 00000000 00000000 00000013"""
    
    print("D5FD Enhanced Record Parser Tool")
    print("Enter 'sample' to use sample data, or paste your hex data:")
    
    user_input = input().strip()
    
    if user_input.lower() == 'sample':
        parser.parse_record(sample_input)
    else:
        parser.parse_record(user_input)

if __name__ == "__main__":
    main()